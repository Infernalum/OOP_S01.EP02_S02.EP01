#ifndef _CARDDECKLIB_H_
#define _CARDDECKLIB_H_

#include <iostream>

#define MAX_INT std::numeric_limits<std::streamsize>::max()

namespace CardDeckClass {


	// Шаблон функции проверки ввода числа ввода числа (1 в случае неудачи, и 0 при успехе)
	template <class T>
	int getNum(T& a, std::istream& stream) {
		int rc = 0;
		stream >> a;
		if (!stream.good())
			rc = 1;				// Обнаружена ошибка ввода
		stream.clear();
		stream.ignore(MAX_INT, '\n');
		return rc;
	};


	// Шаблон функции для ввода числа из входного потока
	template<class T>
	void input_Type(T& p) {
		while (getNum(p, std::cin))
			std::cout << "Пожалуйста, введите корректное число: --> ";
	}



	/* Структура одной карты
	 Вместо интов юзаются чары, чтобы сэкономить память массива, однако сортировка так же идет по номерам в  ASCII таблице */
	struct Card {

		// Ранг карты: от '1' до '9', ':' - Валет, ';' - Дама, '<' - Король, '=' - Туз, '0' - карты не существует
		char rang;

		// Масть карты: '1' - Бубе, '2' - Черви, '3' - Пики, '4' - Крести, '0' - карты не существует
		char suit;
	};

	class CardDeck {
	private:

		// Размер квоты для выделения памяти
		static const int QUOTA = 10;
		int SZ;
		Card* cards;

		// Получение состояния карты без выбрасывания исключения для тестов
		//int GetRang_Test(int i) const { return cards[i - 1].suit; };
		//int GetSuit_Test(int i) const { return cards[i - 1].rang; };

	public:
		/* --------------------------------------------------------- */
		/*				    	  Конструкторы					 	 */
		/* --------------------------------------------------------- */

		// Пустой конструктор для инициализации экземпляров и массивов экземпляров класса по умолчанию
		CardDeck();

		// Создание экземпляра класса с инициализацией количества карт, значения которых определяются с помощью генератора случайных чисел
		// Если нужно создать пустую колоду с конкретным максимальным размеров, юзается значение n по умолчанию
		CardDeck(int, int n = 0);

		// Создание экземпляра класса с инициализацией начального состояия одной карты
		CardDeck(int, int, int);


		// Создание экземпляра класса с его инициализацией другим экземпляром класса (Копирующий конструктор)
		CardDeck(const CardDeck&);

		// 
		static int CompareRang(const void* x1, const void* x2);

		static int CompareSuit(const void* x1, const void* x2);

		/* --------------------------------------------------------- */
		/*				      Сеттеры - set'теры					 */
		/* --------------------------------------------------------- */

		// Добавление новой карты к колоде (Перегруженный префиксный оператор "++")
		CardDeck& AddNewCard();

		// Добавление новой карты к колоде 
		CardDeck& operator ++ ();

		// Сортировка карт в деке по масти (Бубе -> Черви -> Пики -> Крести)
		CardDeck& SortSuit();

		// Сортировка по условию лабы (по масти: Бубе -> Черви -> Пики -> Крести, и убыванию ранга)
		CardDeck& DefaultSort();


		// Переопределение экземпляра класса (Перегруженный оператор присваивания)
		CardDeck& operator = (const CardDeck&);


		/* --------------------------------------------------------- */
		/*				      Геттеры - get'теры 					 */
		/* --------------------------------------------------------- */


		// Вернуть максимальный размер деки
		int GetMaxSize() const { return SZ; };

		// Вернуть текущее кол-во карт в деке
		int GetCurrentSize() const;

		// Вернуть масть карты по её номеру в деке (Перегруженный оператор "()")
		int GetCurrentSuit(int) const;

		// Вернуть масть карты по её номеру в деке
		int operator () (int) const;

		// Вернуть ранг карты по её номеру в деке (Перегруженный оператор "[]")
		int GetCurrentRang(int) const;

		// Вернуть ранг карты по её номеру в деке
		int operator [] (int) const;

		/* Получить подгруппу карт заданной масти из текущей деки (Возвращается новый экземпляр класса)
		Принимает в себя инт от 1 до 4:  '1' - Бубе, '2' - Черви, '3' - Пики, '4' - Крести */
		CardDeck& GetSuitDeck(int) const;


		/* --------------------------------------------------------- */
		/*						 Друзья класса 						 */
		/* --------------------------------------------------------- */

		// Вввод состояния деки из входного потока (с возможным выбрасыванием исключения)
		friend std::istream& operator >> (std::istream&, CardDeck&);

		// Вывод текущей деки в выходной поток
		friend std::ostream& operator << (std::ostream&, const CardDeck&);

		// Деструктор (не по умолчанию, т.к. перед очисткой стека нужно удалить массив)
		~CardDeck();
	};
}


#endif // !_CARDDECK_H_

