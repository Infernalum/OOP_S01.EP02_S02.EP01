#ifndef CELL_H
#define CELL_H

namespace XCom {

	// Класс одной клетки поля
	class Cell {

		char species;					// Тип клетки: символы хранятся в строке species класса "Уровень"
		bool fog;						// Глабальная видимость клетки (туман войны): false - если никто из команды оперативников ее никогда не видел, или true, если иначе.
		bool visible;					// Текущая видимость клетки: видит ли ее кто-то из оперативников на данный момент
		mystd::Table<Item*> itemList;	// Список дропнутых вещей					
		Creature* creature;				// Указатель на существо, которое находится в клетке (либо nullptr, если существа нет)
	public:

		/********************************************************/
		/*					Конструкторы						*/
		/********************************************************/

	/*
		AHCTUNG! ALARM! ВНИМАНИЕ, BLEAAAT
		True Story
		Решил я, значт, запилить зависимость типа клетки от константной строки класса уровня (дабы избежать
	создания клеток неправильного типа) и так, чтобы можно было спокойно и без геммора добавлять еще типы клеток,
	просто включая их в строку спрайтов. И как всегда, кое-кто, бл*ть, забыл, что заголовочные файлы, это ПРЕДВАРИТЕЛЬНОЕ
	объявление переменных. И решил сюда же закинуть inline конструктор, в котором тип клетки задавался как
	Level::get_sprites()[0]. И получал два часа подряд гребучую ошибку с отсутствием такого идентификатора. Логично бл, ибо
	такой функции на этапе подключения h файлов НЕТ. Да и сама строка спрайтов именно поэтому и объявляется в .cpp файле,
	а не в .h
		Мораль сей басни, дети, такова: не путайте, что МОЖНО добавлять в .h файлы, а что нельзя (и последовательность
	включения заголовочных файлов тут не при чем, о чем я думал поначалу)
	*/

	// Конструктор по умолчанию: создает клетку символа "пол", который задан в спрайтах карты как первый символ
		Cell() noexcept;

		// Конструктор, задающий тип спрайта (Задавать указатель на существо во время инициализации поля НЕЛЬЗЯ априори; поэтому он всегда nullptr. Кроме того, индекс спрайта должен существовать)
		Cell(int);

		// Копирующий конструктор
		Cell(const Cell&) noexcept;

		// Копирующий оператор присваивания 
		Cell& operator = (const Cell&) noexcept;

		// Перемещающий конструктор
		Cell(Cell&&) noexcept;

		// Перемещающий оператор присваивания
		Cell& operator = (Cell&&) noexcept;

		// Деструтор 
		~Cell() noexcept;

		/********************************************************/
		/*						Геттеры							*/
		/********************************************************/

		// Получить тип клетки
		char get_species() const noexcept { return species; };

		// Получить состояние о глобальной видимости клетки
		bool get_fog() const noexcept { return fog; };

		// Получить состояние видимости клетки
		bool get_visible() const noexcept { return visible; };

		// Получить указатель на существо
		Creature* get_creature() const noexcept { return creature; };

		// Получить состояние списка предметов (true - пустой, false нет)
		bool empty() const noexcept { return itemList.empty(); };

		// Получить указатель на конкретный предмет из списка вещей (передается НОМЕР предмета)
		Item* get_item(int) const;

		// Вывести список предметов на клетке
		std::ostream& show_list(std::ostream&) const noexcept;

		/********************************************************/
		/*						Сеттеры							*/
		/********************************************************/

		// Изменить тип клетки
		Cell& set_species(char type);

		// Изменить статус "тумана" клетки
		Cell& change_fog() noexcept { fog = !fog; return *this; };

		// Изменить состояние видимости клетки
		Cell& change_visible() noexcept { visible = !visible; return *this; };

		// Установить указатель на существо (вернет exception, если уже есть указатель на существо)
		Cell& set_creature(Creature*);

		// Добавить новый предмет в список вещей на клетке 
		Cell& add_new_item(Item* item) noexcept { itemList.push_back(item); return *this; };

		// Добавить новый предмет в список вещей на клетке 
		Cell& operator += (Item* item) noexcept { return add_new_item(item); };

		/********************************************************/
		/*					Остальные методы					*/
		/********************************************************/

		// Удалить и вернуть указатель на существо, в случае, если оно передвинулось или было уничтожено (УДАЛЕТСЯ НЕ СУЩЕСТВО, А ЗАНУЛЯЕТСЯ УКАЗАТЕЛЬ КЛЕТКИ!!!!); exception, если указатель пуст, не будет, просто выполение ничего не даст
		Creature* loose_creature() noexcept;

		// ВЕЩЬ НЕ МОЖЕТ ИЗЧЕЗНУТЬ С КЛЕТКИ САМА ПО СЕБЕ (Пока что, badabuum). Поэтому после удаления с клетки указателя на вещь, его нужно привязать к существу
		// Удалить какой-то предмет из списка вещей (задается номером вещи в списке, т.к. этот список будет выводиться игроку); вызывается exception, если предмет с таким номером не существует или список пуст 
		Item* erase_item(int);

		// Удалить какой-то предмет из списка вещей (задается номером вещи в списке, т.к. этот список будет выводиться игроку); вызывается exception, если предмет с таким номером не существует или список пуст 
		Item* operator -=(int i) { return erase_item(i); };

		/*
			Вывод клетки: 
		Если она невидима глобально (fog true), то знак '?' (невидимость);
		Если она была засвечена, и засвечена до сих пор (visible true), то отображается либо враг, стоящий на ней, либо предметы, если врага нет, либо тип клетки, если ни того, ни другого нет;
		Если она была засвечена, но в данный момент невидима (visible false), то отображается тип клетки;
		*/
		friend  std::ostream& operator << (std::ostream&, const Cell&);

		// Сохранение информации о клетке в выходной/файловый поток
		std::ostream& save(std::ostream&) const noexcept;

		// Загрузка информции о клетке из входного/файлового потока
		std::istream& load(std::istream&) noexcept;


	};

}

#endif // !_CELL_H_


