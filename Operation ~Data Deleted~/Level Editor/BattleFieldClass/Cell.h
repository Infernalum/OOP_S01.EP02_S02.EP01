#ifndef CELL_H
#define CELL_H

namespace Battlefield {

	// Класс одной клетки поля
	class Cell {
	private:
		char species;				// Тип клетки: '.' - пустая клетка (пол), '#' - стена, '=' - перегородка (стрелять можно; пройти нет), '-' - стекло (после выстрела ломается и превращается в тип 'пол'), '&'- складская точка пришельцев, '(' - предметы на полу; 
		std::list<Item*> itemList;	// Список дропнутых вещей
		Creature* creature;			// Указатель на существо, которое находится в клетке (либо nullptr, если существа нет)
	public:

		/********************************************************/
		/*					Конструкторы						*/
		/********************************************************/

	/*
		AHCTUNG! ALARM! ВНИМАНИЕ, BLEAAAT
		True Story
		Решил я, значт, запилить зависимость типа клетки от константной строки власса уровня (дабы избежать
	создания клеток неправильного типа) и так, чтобы можно было спокойно и без геммора добавлять еще типы клеток,
	просто включая их в строку спрайтов. И как всегда, кое-кто, бл*ть, забыл, что заголовочные файлы, это ПРЕДВАРИТЕЛЬНОЕ
	объявление переменных. И решил сюда же закинуть inline конструктор, в котором тип клетки задавался как
	Level::get_sprites()[0]. И получал два часа подряд гребучую ошибку с отсутствием такого идентификатора. Логично бл, ибо
	такой функции на этапе подключения h файлов НЕТ. Да и сама строка спрайтов именно поэтому и объявляется в .cpp файле,
	а не в .h
		Мораль сей басни, дети, такова: не путайте, что МОЖНО добавлять в .h файлы, а что нельзя (и последовательность
	включения заголовочных файлов тут не при чем, о чем я думал поначалу)
	*/

	// Конструктор по умолчанию: создает клетку символа "пол", который задан в спрайтах карты как первый символ
		Cell() noexcept;

		// Конструктор, задающий тип спрайта (Задавать указатель на существо во время инициализации поля НЕЛЬЗЯ априори; поэтому он всегда nullptr. Кроме того, индекс спрайта должен существовать)
		Cell(int);

		// Копирующий конструктор (Хреново, ооочень хреново)
		Cell(const Cell&) noexcept;

		// Копирующий оператор присваивания 
		Cell& operator = (const Cell&) noexcept;

		// Перемещающий конструктор (Уже лучше)
		Cell(Cell&&) noexcept;

		// Перемещающий оператор присваивания
		Cell& operator = (Cell&&) noexcept;

		// Деструтор (Подразумевается, что удаление всего класса будет происходить с помощью удаления игрового поля; удалется клетка со ВСЕМ содержимым)
		~Cell();

		/********************************************************/
		/*						Геттеры							*/
		/********************************************************/

		// Получить тип клетки
		char get_species() const noexcept { return species; };

		// Получить указатель на существо
		Creature* get_creature() const noexcept { return creature; };


		// Получить указатель на конкретный предмет из списка вещей (вызывается exception, если предмета с таким номером нет в списке, либо список пуст)
		Item* get_item(int) const;


		/********************************************************/
		/*						Сеттеры							*/
		/********************************************************/

		// Изменить тип клетки
		Cell& set_species(char type);

		// Установить указатель на существо (вернет exception, если уже есть указатель на существо)
		Cell& set_creature(Creature*);

		// Добавить новый предмет в список вещей на клетке (Почему не работает const??)
		Cell& add_item(Item* item) noexcept { itemList.push_back(item); return *this; };

		// Добавить новый предмет в список вещей на клетке (Почему не работает const??)
		Cell& operator += (Item* item) noexcept { return add_item(item); };

		/********************************************************/
		/*					Остальные методы					*/
		/********************************************************/

		// Удалить и вернуть указатель на существо, в случае, если оно передвинулось или было уничтожено (УДАЛЕТСЯ НЕ СУЩЕСТВО, А ЗАНУЛЯЕТСЯ УКАЗАТЕЛЬ КЛЕТКИ!!!!); exception, если указатель пуст, не будет, просто выполение ничего не даст
		Creature* loose_creature() noexcept;

		// ВЕЩЬ НЕ МОЖЕТ ИЗЧЕЗНУТЬ С КЛЕТКИ САМА ПО СЕБЕ (Пока что, badabuum). Поэтому после удаления с клетки указателя на вещь, его нужно привязать к существу
		// Удалить какой-то предмет из списка вещей (задается номером вещи в списке, т.к. этот список будет выводиться игроку); вызывается exception, если предмет с таким номером не существует или список пуст 
		Item* erase_item(int);

		// Удалить какой-то предмет из списка вещей (задается номером вещи в списке, т.к. этот список будет выводиться игроку); вызывается exception, если предмет с таким номером не существует или список пуст 
		Item* operator -=(int i) { return erase_item(i); };

		// Вывод типа клетки (символа)
		friend  std::ostream& operator << (std::ostream&, const Cell&);

	};

}

#endif // !_CELL_H_


