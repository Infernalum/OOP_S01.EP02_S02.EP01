#ifndef ITEM_H
#define ITEM_H


namespace XCom {

	class Item {
	private:

		// Кол-во очков, которые нужно потратить, чтобы заюзать предмет (выстрелить, захилиться, перезарядиться и тд)
		int usedPoint;

	protected:

		virtual std::ostream& print(std::ostream&) const;

		// Помещаем конструкторы в protected область, чтобы невозможно было даже
		// пытаться создать объекты абстрактного класса, но доступ к ним имели дочерние классы

		/* Правило: никогда не вызывать виртуальные функции в теле конструкторов или деструкторов базовых классов */

		/********************************************************/
		/*					 Конструкторы						*/
		/********************************************************/

		// Копирующие/перемещающие конструкторы по умолчанию

		// Единственный конструктор
		Item(int uP = 1);


		// Вес предмета (считается отдельно, т.к. для аптечки и оружейного ящика (да и для оружия) вес высчитывается с учетом сотояния дочерних классов
		double weight;

	public:

		/********************************************************/
		/*						Геттеры							*/
		/********************************************************/

		double get_weight() { return weight; };
		int get_uP() { return usedPoint; };



		/********************************************************/
		/*						Сеттеры							*/
		/********************************************************/

		// Изменение веса предмета (для кадого типа предмета свой метод подсчета веса)
		virtual const Item& set_weight() = 0;

		/*
			Использование предемета.
		Для оружейного ящика: вытащить n патронов из ящика; в случае, если в ящике меньше патронов, вытаскивается кол-во, которое можно забрать
		Для аптечки: использовать аптечку (после использования аптечка удаляется)
		Для оружия: выстрелить 1-им патроном. Вычисляется шанс попадания для расстояния в n клеток
		*/
		virtual int using_item(int) = 0;

		Item& set_usedPoint(int);

		/********************************************************/
		/*					Остальные методы					*/
		/********************************************************/


		// Создание копии предмета
		Item* clone() { return this; };

		friend std::ostream& operator << (std::ostream& os, const Item& c) { return c.print(os); };

	};

}

#endif // !_ITEM_H_



