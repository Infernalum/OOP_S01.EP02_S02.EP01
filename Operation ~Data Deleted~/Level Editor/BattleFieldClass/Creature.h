#ifndef CREATURE_H
#define CREATURE_H


namespace Battlefield {

	// Базовый абстрактный класс "Существо"
	class Creature {

		// Вообще, мне нужна дружественной из Level только функция add_to_level, но у меня не получается ее оъявить
		friend class Level;

	private:
		//static const std::string fraction;	// "Тип" существа (к какой стороне пренадлежит - "Alien" или "Operative")"
		int x, y;								// Координаты клетки, на которой стоит существо
		int HP, maxHP;							// Текущее \ максимальное кол-во очков здоровья
		int evasion;							// Параметр уклонения существа: снижает шанс попадания (варьируется от 0 - нет бонуса, до 100% - уменьшает шанс в 2 раза)
		int accuracy;							// Параметр точности существа: показывает, каков шанс нанести урон от стандартного шанса оружием. 0 - шансов нет (ослеплен), 100 - обычная точность
		int TP, maxTP;							// Текущее \ максимальное кол-во очков времени
		int sight;								// Радиус обзора существа
		//std::list<Creature*> visible;			// Список существ, которых видит существо
	protected:

		// Символ, которым будет обозначаться данный класс существ на карте
		static const char marking;

		/* В protected область добавляем функцию вывода, чтобы доступ к ней имели и дочерние классы,
		но напрямую обращаться к ней было нельзя, т.е. вывод происходил только через перегруженный оператор
		То есть, при вызове перегруженного оператора вывода в дочерних классах будет вызываться ИХ метод print,
		а при использовании в них перегруженного вывода для абстрактного класса, будет использоваться перегруженный
		вывод абстрактного класса через его метод print; кроме того, заключая все эти методы print в protected-область,
		мы гарантируем, что: a) их вызывать будет НЕЛЬЗЯ b) производные классы СМОГУТ вызывать перегруженный оператор
		базового класса
		*/
		virtual std::ostream& print(std::ostream&) const;

	public:

		virtual const char name() const = 0;

		virtual Creature& set_damage(int) = 0;

		/********************************************************/
		/*					 Конструкторы						*/
		/********************************************************/

		// Конструктор существа по умолчанию; менять максимальные хар-ки будем через сеттеры
		// Существо с текущим кол-вом здоровья 0 существовать НЕ МОЖЕТ
		Creature(int s = 1, int mh = 1, int mtp = 1, int mw = 1)
			: x(-1), y(-1), sight(s), evasion(0), accuracy(100), HP(mh), maxHP(mh), TP(mtp), maxTP(mtp) {};




		/********************************************************/
		/*						Геттеры							*/
		/********************************************************/

		// Получение базовых характеристик абстрактного класса
		int get_x() const { return x; };
		int get_y() const { return y; };
		int get_HP() const { return HP; };
		int get_TP() const { return TP; };
		int get_maxTP() const { return maxTP; };
		int get_maxHP() const { return maxHP; };
		int get_sight() const { return sight; };
		int get_evasion() const { return evasion; };
		int get_accurany() const { return accuracy; };



		/********************************************************/
		/*						Сеттеры							*/
		/********************************************************/

		/* Изменение стандартных хар-к существа: при попытке установки текущих хар-к на значение,
		превышающее максимальное, состояние устанавливается на максимальное значение.
		   В случае установки максимального значения на то, которое меньше текущего, текущее значение
		меняется на максимальное
			Текущие хар-ки существа менять просто так нельзя; они по дефолту
		до введения его на поле будут совпадать с максимальными */

		Creature& set_x(int);
		Creature& set_y(int);
		Creature& set_HP(int);
		Creature& set_TP(int);
		Creature& set_maxHP(int);
		Creature& set_maxTP(int);
		Creature& set_sight(int);
		Creature& set_evasion(int);
		Creature& set_accuracy(int);



		/********************************************************/
		/*					Остальные методы					*/
		/********************************************************/

		friend std::ostream& operator << (std::ostream& os, const Creature& c) { return c.print(os); };

		virtual Creature* clone() const = 0;	// Виртуальная функция создания копии существа
		virtual ~Creature() {};					// Виртуальный деструктор
	};

}
#endif // !_CREATURE_H_


