#ifndef LEVEL_H
#define LEVEL_H


// Класс Самой игрушки
namespace Battlefield {

	// forward declaration
	class Cell;

	// Шаблон функции проверки ввода данных (1 в случае неудачи, и 0 при успехе)
	template <class T>
	int getType(T& a, std::istream& stream) {
		int rc = 0;
		stream >> a;
		if (!stream.good())
			rc = 1;				// Обнаружена ошибка ввода
		stream.clear();
		stream.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
		return rc;
	};


	// Шаблон функции для ввода данных из входного потока
	template<class T>
	void inputType(T& p, std::istream& istream, std::ostream& ostream) {
		while (getType(p, istream))
			ostream << "Пожалуйста, повторите ввод: --> ";
	}


	// Класс "Уровень"
	class Level {
	private:
		static const std::string sprites;		// Спрайты карты (5 символов). 
		/* Порядок:
		[0] - пол (ascii 46);
		[1] - стена (35);
		[2] - стекло (61);
		[3] - перегородка (45);
		[4] - складская точка пришельцев (38);
		[5] - предметы на полу (40); тип клетки с [0] переставляется на [5], если есть предеметы и кто-то из оперативников "засветил" клетку
		Можно добавить еще какой-нибудь тип клетки, связь с клеткой и полем не нарушится,
		но нужно будет реализовать взаимодействие этого типа с существами
		 */
		static const std::string markingAlien;		// Символы, обозначающие классы пришельцев на консольной карте
		/* Порядок:
		[0] - криссалид;
		[1] - фуражир;
		[2] - разумное существо;
		Для всех оперативников переменная marking = 0, а выводиться на карту будет символ-позывной (callsign), который вводится при создании оперативника
		*/


		std::list<Creature*> SquadOperative;		// Тима оперативников
		std::list<Creature*> SquadAliens;			// Тима пришельцев
		std::vector<std::vector<Cell>> field;		// Само игровое поле (прямоугольное)

	public:

		/********************************************************/
		/*					Конструкторы						*/
		/********************************************************/

		/* Единственный конструктор, который задает поле размером n*m
		ВНИМАНИЕ! ПЕРВОЕ ЧИСЛО m - ШИРИНА, ВТОРОЕ - ДЛИНА ПОЛЯ!!!!!
		*/
		Level(int n = 1, int m = 1) : field(m, std::vector<Cell>(n)) {};

		// Копирующий конструктор
		Level(const Level&) noexcept;

		// Копирующий оператор присваивания
		Level& operator =(const Level&) noexcept;

		/*
			Перемещающий конструктор
		 По идее, "перемещение" списков происходит так: копируются все адреса в элементы соответствующих списков,
		 Сами элементы не используют копирование/перемещение (т.к. выделены динамически), => связь с существами остается
		 и при вызове деструктора для списков поля copy ничего не теряется. Но что происходит с вектором? Если
		 при инициализации вектора вызывается копирующий конструктор для клеток, то все плохо, а если перемещающий, то збс.
		Нашел только std::move для того чтобы преобразовать вектор к r-value. Тогда для клеток будет вызываться move-конструктор
		*/
		Level(Level&& copy) noexcept : field(std::move(copy.field)), SquadOperative(copy.SquadOperative), SquadAliens(copy.SquadAliens) {};

		// Перемещающий оператор присваивания
		Level& operator =(Level&&) noexcept;


		// Деструктор
		~Level();

		/********************************************************/
		/*						Геттеры							*/
		/********************************************************/

		// Вывести список символов, отвечающих за спрайты (нужно для автоматического изменения символа в строке спрайтов и чтобы ниче не сломалось)
		const std::ostream& print_sptites(std::ostream&) const noexcept;


		// Получить спрайты карты (для установки типа клетки)
		static const std::string get_sprites() noexcept { return sprites; };

		/********************************************************/
		/*						Сеттеры							*/
		/********************************************************/

		// Все переметры принимают не индекс массива (от 0 до n - 1/m - 1), а номер клетки (от 1 до n/m) 



		// Устанавливает размеры игрового поля (и создает соотв. поле из клеток по умолчанию); при создании нового поля, старое стирается
		Level& set_proportions(int, int);

		// Позволяет изменить тип конкретной клетки, задающейся коор-тами x и y
		Level& set_cell(int, int, int);

		// Добавляем существо в тиму и на поле: (1 - проверяем клетку; добавляем на поле; добавляем в список)
		Level& add_to_level(Creature*, int, int);

		// Отвязать существо от клетки (возвращает nullptr, если существа нет, и адрес существа в куче в противном случае)
		Creature* loose_creature(int, int);

		/********************************************************/
		/*					Другие методы						*/
		/********************************************************/

		// Ввод игрового поля
		friend std::istream& operator >> (std::istream&, Level&);

		// Вывод игрового поля
		friend std::ostream& operator << (std::ostream&, const Level&);


	};
}

#endif // !_BATTLEFIELD_H_

