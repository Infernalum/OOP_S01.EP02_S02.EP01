#ifndef LEVEL_H
#define LEVEL_H


// Класс Самой игрушки
namespace XCom {

	// forward declaration
	class Cell;

	// Шаблон функции проверки ввода данных (1 в случае неудачи, и 0 при успехе)
	template <class T>
	int getType(T& a, std::istream& stream) {
		int rc = 0;
		stream >> a;
		if (!stream.good())
			rc = 1;				// Обнаружена ошибка ввода
		stream.clear();
		stream.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
		return rc;
	};


	// Шаблон функции для ввода данных из входного потока
	template<class T>
	void inputType(T& p, std::istream& istream, std::ostream& ostream) {
		while (getType(p, istream))
			ostream << "Пожалуйста, повторите ввод: --> ";
	}


	// Класс "Уровень"
	class Level {
		/*
	Спрайты карты (5 символов).
		Порядок:
	[0] - пустая клетка (пол); '.' - ascii 46;
	[1] - стена; '#' - 35;
	[2] - стекло - после выстрела ломается и превращается в тип "пол"; '-' - ascii 61;
	[3] - перегородка - видеть/стрелять можно, пройти нет; '=' - ascii 45;
	[4] - складская точка пришельцев; '&' - ascii 38;
	НЕ тип клетки!!
	[5] - предметы на полу; '!' - ascii 33;
	   Для предметов на полу: они НЕ являются типом клетки, это спрайт для отображения на игровом поле.
	Если клетка, на которой есть какие-то предметы, засветилась первый раз, она отображает предметы (sptites[5]).
	Если же клетка выходит из поля видимости всех оперативников, она отображает свой тип (становится просто полом).
	При повторном попадании снова отображает предметы.
	Та же механика и с пришельцами.
	Можно добавить еще какой-нибудь тип клетки, связь с клеткой и полем не нарушится,
	но нужно будет реализовать взаимодействие этого типа с существами
	 */
		static const std::string sprites;
		/*
			Символы, обозначающие классы пришельцев на консольной карте
		Порядок:
			[0] - криссалид;
			[1] - фуражир;
			[2] - разумное существо;
		Для всех оперативников переменная marking = 0, а выводиться на карту будет символ-позывной (callsign), который вводится при создании оперативника
		*/
		static const std::string markingAlien;

		std::list<Creature*> squadOperative;				// Тима оперативников
		std::list<Creature*> squadAliens;					// Тима пришельцев
		std::vector<std::vector<Cell>> field;				// Само игровое поле (прямоугольное)
		std::vector<Ammo> ammo;								// Типы патронов в игре


	public:

		/********************************************************/
		/*					Конструкторы						*/
		/********************************************************/

		// Единственный конструктор, который задает поле размером n*m и единсвтеннный тип патронов по умолчанию
		Level(int n = 1, int m = 1) : field(m, std::vector<Cell>(n)), ammo(1) {};

		// Копирующий конструктор
		Level(const Level&) noexcept;

		// Копирующий оператор присваивания
		Level& operator =(const Level&) noexcept;

		/*
			Перемещающий конструктор
		 По идее, "перемещение" списков происходит так: копируются все адреса в элементы соответствующих списков,
		 Сами элементы не используют копирование/перемещение (т.к. выделены динамически), => связь с существами остается
		 и при вызове деструктора для списков поля copy ничего не теряется. Но что происходит с вектором? Если
		 при инициализации вектора вызывается копирующий конструктор для клеток, то все плохо, а если перемещающий, то збс.
		Нашел только std::move для того чтобы преобразовать вектор к r-value. Тогда для клеток будет вызываться move-конструктор
		*/
		Level(Level&& copy) noexcept : field(std::move(copy.field)), squadOperative(copy.squadOperative), squadAliens(copy.squadAliens) {};

		// Перемещающий оператор присваивания
		Level& operator =(Level&&) noexcept;


		// Деструктор
		~Level();

		/********************************************************/
		/*						Геттеры							*/
		/********************************************************/

		// Вывести список символов, отвечающих за спрайты (нужно для автоматического изменения символа в строке спрайтов и чтобы ниче не сломалось)
		const std::ostream& print_sptites(std::ostream&) const noexcept;


		// Получить спрайты карты (для установки типа клетки)
		static const std::string get_sprites() noexcept { return sprites; };

		/********************************************************/
		/*						Сеттеры							*/
		/********************************************************/

		// Получить доступ к вектору типов патронов
		std::vector<Ammo>& get_access_to_ammo() { return ammo; };

		// Все пареметры принимают не индекс массива (от 0 до n - 1/m - 1), а номер клетки (от 1 до n/m) 



		// Устанавливает размеры игрового поля (и создает соотв. поле из клеток по умолчанию); при создании нового поля, старое стирается
		Level& set_proportions(int, int);

		// Позволяет изменить тип конкретной клетки, задающейся коор-тами x и y
		Level& set_cell(int, int, int);

		// Добавляем существо в тиму и на поле: (1 - проверяем клетку; добавляем на поле; добавляем в список)
		Level& add_to_level(Creature*, int, int);

		// Отвязать существо от клетки (возвращает nullptr, если существа нет, и адрес существа в куче в противном случае)
		Creature* loose_creature(int, int);

		/********************************************************/
		/*					Другие методы						*/
		/********************************************************/

		// Ввод игрового поля
		friend std::istream& operator >> (std::istream&, Level&);

		// Вывод игрового поля
		friend std::ostream& operator << (std::ostream&, const Level&);


	};
}

#endif // !_BATTLEFIELD_H_

