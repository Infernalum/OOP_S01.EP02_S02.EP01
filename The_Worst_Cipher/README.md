# Разработка машинного шифровщика 
___ 
### Цель работы: используя класс, разработанный другим студентом, написать программу (НЕ ОТЛАДОЧНУЮ), реализующую работу через данный класс. 
Требования: 
1) Программа не должна быть отладочной (т.е. проверять исключительно функционал данного класса); подразумевается, что выбранный класс уже отлажен и протестирован;
2) Класс должен быть подключен к проекту как статическая библиотека, собранная студентом-разработчиком данного класса;
3) Не допускается изменение/рефакторинг выбранного класса - можно использовать лишь предоставленную документацию (собранную библиотеку и заголовочный файл класса)
___

Мне выпал саморучно написанный класс "стек", имеющий возможность хранить любые типы данных, в т.ч. кастомные (правильность их хранения я не проверял, ограничился лишь проверкой наличия перемещаещего конструктора и assignment'а). В голову сразу пришла мысль про обратную польскую (постфиксную) нотацию (один из принципов преобразования ар. выражений в вид, который понимает машина, хотя, кому я это рассказываю, вы и так об этом знаете). Но это было бы слишком просто, хотя и охватывало бы весь спектр возможностей предоставленного класса (проверял бы все возможные варианты работы). Но ничего нового не придумывалось, поэтому я решил скомунниздить идею постфиксной записи и запилить шифр, работающий по этому же принципу. Предрекая ожидания, нет, это судя по всему, не новый шифр, и да, он имеет очень много недостатков, и взломать его просто, но задачу он выполнил. <br/> Работа шифровальщика, на самом деле, очень проста: на вход подается строка (слово/текст, не важно) с чувствительным регистром, разделенная одним или несколькими пробелами/знаками табуляции и знаками препинания (они в шифровании участвуют). А на выходе получаем зашифрованную строку (из тех же символов, т.е. не меняя букв и цифр, чтобы было нагляднее) и ключ к ней. Чтобы расшифровать, достаточно вбить зашифрованную строку и ключ в дешифровщик в этой же программе, чтобы получить обычный текст. <br/> Как я и говорил, у этого шифра (и программы) больше минусов, чем плюсов, а именно: 
<br/> +: Как один из этапов шифрования сгодится;<br/> +: Оно работает (!);
<br/> В приницпе, это все. Теперь минусы:
<br/> -: Из-за принципа работы не годится для шифровки коротких слов (меньше 4 букв);<br/> -: Слишком уж длинные ключи к строкам (а это я его еще в 16-тиричный вид перевел, так он в 4 раза длиннее), что не дает возможности адаптировать текст для ручной дешифровки (хотя, сам шифр этого не предполагает, реально зашибешься это на бумаге делать); <br/> -: (Пожалуй, самый главный минус) Мало того, что при неправильном ключе нас пошлют, это вроде бы логично, но сам шифр НЕ однозначный. То есть ключ к строке мы поменять можем, достаточно перезапустить прогу :). Но работать он будет. А вот строка - них(кря)я. То есть для одного ключа подходит бесконечное кол-во строк конкретной одинаковой длины, и дешифровщик эти строки и правда "расшифрует" (Т.к. ключ - это по сути правило перестановки символов в последовательности символов данной длины). Короче, взаимной однозначности не получилось, а значит, и уникальным шифром это официально назвать нельзя. В принципе, можно было бы добавить еще один ключ на проверку соответсвия, но это уже чересчур геморрно. 
<br/> Ниже скриншот-пример работы шифровщика и дешифровщика к исходной и зашифрованной строке (опять же, поменяв символы в зашифрованной строке, он ее расшифрует, чего быть не должно)

<details>
  <summary>Принцип работы, думаю, все уже поняли, но вот немного поподробнее: </summary>
  1) Входное слово/строка/текст конвертируются
</details>
  
![Alt-текст](https://github.com/Infernalum/OOP_S01.EP02_S02.EP01/blob/master/The_Worst_Cipher/example.png)
