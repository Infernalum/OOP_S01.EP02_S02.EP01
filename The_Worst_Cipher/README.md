# Разработка машинного шифрования
___ 
### Цель работы: используя класс, разработанный другим студентом, написать программу (НЕ ОТЛАДОЧНУЮ), реализующую работу через данный класс. 
Требования: 
1) Программа не должна быть отладочной (т.е. проверять исключительно функционал данного класса); подразумевается, что выбранный класс уже отлажен и протестирован;
2) Класс должен быть подключен к проекту как статическая библиотека, собранная студентом-разработчиком данного класса;
3) Не допускается изменение/рефакторинг выбранного класса - можно использовать лишь предоставленную документацию (собранную библиотеку и заголовочный файл класса)
___

Мне выпал саморучно написанный класс "стек", имеющий возможность хранить любые типы данных, в т.ч. кастомные (правильность их хранения я не проверял, ограничился лишь проверкой наличия перемещаещего конструктора и assignment'а). В голову сразу пришла мысль про обратную польскую (постфиксную) нотацию (один из принципов преобразования ар. выражений в вид, который понимает машина, хотя, кому я это рассказываю, вы и так об этом знаете). Но это было бы слишком просто, хотя и охватывало бы весь спектр возможностей предоставленного класса (проверял бы все возможные варианты работы). Но ничего нового не придумывалось, поэтому я решил скомунниздить идею постфиксной записи и запилить шифр, работающий по этому же принципу. Предрекая ожидания, нет, это судя по всему, не новый шифр, и да, он имеет очень много недостатков, и взломать его просто, но задачу он выполнил. <br/> Работа шифровальщика, на самом деле, очень проста: на вход подается строка (слово/текст, не важно) с чувствительным регистром, разделенная одним или несколькими пробелами/знаками табуляции и знаками препинания (они в шифровании участвуют). А на выходе получаем зашифрованную строку (из тех же символов, т.е. не меняя букв и цифр, чтобы было нагляднее) и ключ к ней. Чтобы расшифровать, достаточно вбить зашифрованную строку и ключ в дешифровщик в этой же программе, чтобы получить обычный текст. <br/> Как я и говорил, у этого шифра (и программы) больше минусов, чем плюсов, а именно: 
<br/> +: Как один из этапов шифрования сгодится;<br/> +: Оно работает (!);
<br/> В приницпе, это все. Теперь минусы:
<br/> -: Из-за принципа работы не годится для шифровки коротких слов (меньше 4 букв);<br/> -: Слишком уж длинные ключи к строкам (а это я его еще в 16-тиричный вид перевел, так он в 4 раза длиннее), что не дает возможности адаптировать текст для ручной дешифровки (хотя, сам шифр этого не предполагает, реально зашибешься это на бумаге делать); <br/> -: (Пожалуй, самый главный минус) Мало того, что при неправильном ключе нас пошлют, это вроде бы логично, но сам шифр НЕ однозначный. То есть ключ к строке мы поменять можем, достаточно перезапустить прогу :). Но работать он будет. А вот строка - них(кря)я. То есть для одного ключа подходит бесконечное кол-во строк конкретной одинаковой длины, и дешифровщик эти строки и правда "расшифрует" (Т.к. ключ - это по сути правило перестановки символов в последовательности символов данной длины). Короче, взаимной однозначности не получилось, а значит, и уникальным шифром это официально назвать нельзя. В принципе, можно было бы добавить еще один ключ на проверку соответсвия, но это уже чересчур геморрно. 
<br/> Ниже скриншот-пример работы шифровщика и дешифровщика к исходной и зашифрованной строке (опять же, поменяв символы в зашифрованной строке, он ее расшифрует, чего быть не должно)

<details>
  <summary>Принцип работы, думаю, все уже поняли, но вот немного поподробнее: </summary>
  1)  Входное слово/строка/текст преобразуется в строку без лишних пробельных символов;
  <br/>2)  Далее для каждого слова в строке (максимально тупым) рандомом создается арифмитическое выражение такой же длины, что и слово, из цифр 0 - 5, где 0 - число; 1 - знак низкого приоритета (+ и -); 2 - высокого (* и /); 3 - стоп-знак (о нем ниже); 4-5 - открывающаяся и закрывающаяся скобки соотвественно. Потом в соответсвие каждому элементу сгенерированного выражения из цифр 0-5 ставится буква из слова, и к выражению применяется посфиксная запись. Полученная после операции посл-ть букв и цифр в двоичном виде и есть часть зашифрованной строки и кода. Ах да, ну и потом, чтобы сложнее было понять, реверсируем и строку, и ключ (ненуаче). Так, применяя к каждому слову данный принцип, получаем каждый раз новые зашифрованные выражения, и конкатенируем их с зашифрованной частью и ключом. По этой причине шифр и работает плохо для коротких слов: для слова из трех букв шифров всего два: 010 (или 020, в принципе, не очень отличается), для которого посфиксная запись 001 (002).
  <br/>3)    Но вот проблема: Если зашифровать так строку изи, то обратно расшифровать уже все, гг. Почему? Да потому что если вдуматься в принцип работы, то станет понятно, что при расшифровке ключа обратно из постфиксной записи в человечекую могут быть неоднозначности: где кончается отдельное слово, как зашифровать слова из четного кол-ва букв (напр. четырех), и тд. Поэтому я ввел т.н. "стоп-знак": обычный ноль в конце четных слов. Что это дает? А то, что таким Макаром в конце каждого выражения ВСЕГДА будет последовательность из двух нулей, которая никак, кроме этого стоп-знака появиться не может (ну не может посфиксная запись кончаться на два числа, или начинаться со знака, т.е. не с нуля). И тогда, видя эту парочку, дешифровщик понимает: "ага, конец слова is out here". Но как тогда понять, нужно ли тут брать один ноль, или эти два нуля уже начало следующего слова? Тут опять же играет роль четность: мы идет задом-наперед при дешифровке, т.е. если кол-во цифр в записи четное, то один ноль из "00", это стоп-знак; если же нечетное - все норм, эти два нуля из следующего слова. 
  Таким образом, я не вижу способа связать зашифрованную строку с ключом, так как по сути, они друг от друга никак не зависят, но это уже другая история, ибо основную цель - заюзать левый класс в неотладочных целях - я выполнил. И согласитесь - выглядит она все таки как-никак "зашифрованно" :)
</details>
  
![Alt-текст](https://github.com/Infernalum/OOP_S01.EP02_S02.EP01/blob/master/The_Worst_Cipher/example.png)
