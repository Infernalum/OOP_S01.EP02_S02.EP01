#ifndef CARDDECKLIB_A_B_H
#define CARDDECKLIB_A_B_H

#include <iostream>
#include <limits>

#define MAX_INT std::numeric_limits<std::streamsize>::max()

namespace CardDeckClass {

// Шаблон функции проверки ввода числа ввода числа (1 в случае неудачи, и 0 при
// успехе)
template <class T>
int getNum(T& a, std::istream& stream) {
  int rc = 0;
  stream >> a;
  if (!stream.good())
    rc = 1;  // Обнаружена ошибка ввода
  stream.clear();
  stream.ignore(MAX_INT, '\n');
  return rc;
};

// Шаблон функции для ввода числа из входного потока
template <class T>
void input_Type(T& p) {
  while (getNum(p, std::cin))
    std::cout << "Пожалуйста, введите корректное число: --> ";
}

/* Структура одной карты
 Вместо интов юзаются чары, чтобы сэкономить память массива, однако сортировка
 так же идет по номерам в  ASCII таблице */
struct Card {
  // Ранг карты: от '0' до '9', ':' - Валет, ';' - Дама, '<' - Король, '=' -
  // Туз, '>' - карты не существует
  char rang;

  // Масть карты: '1' - Бубе, '2' - Черви, '3' - Пики, '4' - Крести, '0' - карты
  // не существует
  char suit;
};

class CardDeck {
 private:
  static const int SZ = 52;
  Card cards[SZ];

 public:
  /* --------------------------------------------------------- */
  /*				    	  Конструкторы
   */
  /* --------------------------------------------------------- */

  // Пустой конструктор для инициализации экземпляров и массивов экземпляров
  // класса по умолчанию
  CardDeck();

  // Создание экземпляра класса с инициализацией количества карт, значения
  // которых определяются с помощью генератора случайных чисел
  CardDeck(int);

  // Создание экземпляра класса с инициализацией начального состояия одной карты
  CardDeck(int, int);

  /* --------------------------------------------------------- */
  /*				      Сеттеры - set'теры
   */
  /* --------------------------------------------------------- */

  // Добавление новой карты к колоде (Перегруженный префиксный оператор "++")
  CardDeck& AddNewCard();

  // Перегруженный оператор с таким функционалом
  CardDeck& operator++();

  // Сортировка карт в деке по масти (Бубе -> Черви -> Пики -> Крести)
  CardDeck& SortSuit();

  // Сортировка по условию лабы (по масти: Бубе -> Черви -> Пики -> Крести, и
  // убыванию ранга)
  CardDeck& DefaultSort();

  /* --------------------------------------------------------- */
  /*				      Геттеры - get'теры
   */
  /* --------------------------------------------------------- */

  // Вернуть максимальный размер деки
  int GetMaxSize() const { return SZ; };

  // Вернуть текущее кол-во карт в деке
  int GetCurrentSize() const;

  // Найти индекс конкретной карты в колоде (Необходима только для 3А и 3Б, т.к.
  // в фулл деке кол-во все карты индивидуальны)
  int FindCurrentCard(int, int) const;

  // Вернуть масть карты по её номеру в деке (Перегруженный оператор "()")
  int GetCurrentSuit(int) const;

  // Перегруженный оператор с таким функционалом
  int operator()(int) const;

  // Вернуть ранг карты по её номеру в деке (Перегруженный оператор "[]")
  int GetCurrentRang(int) const;

  // Перегруженный оператор с таким функционалом
  int operator[](int) const;

  /* Получить подгруппу карт заданной масти из текущей деки (Возвращается новый
  экземпляр класса) Принимает в себя инт от 1 до 4:  '1' - Бубе, '2' - Черви,
  '3' - Пики, '4' - Крести */
  CardDeck& GetSuitDeck(int) const;

  /* --------------------------------------------------------- */
  /*						 Друзья класса
   */
  /* --------------------------------------------------------- */

  // Вввод состояния деки из входного потока (с возможным выбрасыванием
  // исключения)
  friend std::istream& operator>>(std::istream&, CardDeck&);

  // Вывод текущей деки в выходной поток
  friend std::ostream& operator<<(std::ostream&, const CardDeck&);

  // Деструктор (не по умолчанию, т.к. перед очисткой стека нужно удалить
  // массив)
  //~CardDeck();
};
}  // namespace CardDeckClass

#endif  // CARDDECKLIB_A_B_H
