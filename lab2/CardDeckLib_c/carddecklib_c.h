#ifndef CARDDECKLIB_C_H
#define CARDDECKLIB_C_H

#include <iostream>
#include <limits>

#define MAX_INT std::numeric_limits<std::streamsize>::max()

namespace CardDeckClass {

// Шаблон функции проверки ввода числа ввода числа (1 в случае неудачи, и 0 при
// успехе)
template <class T>
int getNum(T& a, std::istream& stream) {
  int rc = 0;
  stream >> a;
  if (!stream.good())
    rc = 1;  // Обнаружена ошибка ввода
  stream.clear();
  stream.ignore(MAX_INT, '\n');
  return rc;
};

// Шаблон функции для ввода числа из входного потока
template <class T>
void input_Type(T& p) {
  while (getNum(p, std::cin))
    std::cout << "Пожалуйста, введите корректное число: --> ";
}

/* Структура одной карты
 Вместо интов юзаются чары, чтобы сэкономить память массива, однако сортировка
 так же идет по номерам в  ASCII таблице */
struct Card {
  // Ранг карты: от '1' до '9', ':' - Валет, ';' - Дама, '<' - Король, '=' -
  // Туз, '0' - карты не существует
  char rang;

  // Масть карты: '1' - Бубе, '2' - Черви, '3' - Пики, '4' - Крести, '0' - карты
  // не существует
  char suit;
};

class CardDeck {
 public:
  // Массивы соответствия чаров для карты и ее ранга и масти
  static const char* Rangs[13];

  static const char* Suits[4];

 private:
  // Размер квоты для выделения памяти
  static const int QUOTA = 10;
  int SZ;
  Card* cards;

 public:
  /* --------------------------------------------------------- */
  /*				    	  Конструкторы
   */
  /* --------------------------------------------------------- */

  // Пустой конструктор для инициализации экземпляров и массивов экземпляров
  // класса по умолчанию
  CardDeck();

  // Создание экземпляра класса с инициализацией количества карт, значения
  // которых определяются с помощью генератора случайных чисел Если нужно
  // создать пустую колоду с конкретным максимальным размеров, юзается значение
  // n по умолчанию
  CardDeck(int, int n = 0);

  // Создание экземпляра класса с инициализацией начального состояия одной карты
  CardDeck(int, int, int);

  // Создание экземпляра класса с его инициализацией другим экземпляром класса
  // (Копирующий конструктор)
  CardDeck(const CardDeck&);

  // Компораторы для qsort
  static int CompareRang(const void* x1, const void* x2);

  static int CompareSuit(const void* x1, const void* x2);

  /* --------------------------------------------------------- */
  /*				      Сеттеры - set'теры
   */
  /* --------------------------------------------------------- */

  // Добавление новой карты к колоде (Перегруженный префиксный оператор "++")
  CardDeck& AddNewCard();

  // Добавление новой карты к колоде
  CardDeck& operator++();

  // Сортировка карт в деке по масти (Бубе -> Черви -> Пики -> Крести)
  CardDeck& SortSuit();

  // Сортировка по условию лабы (по масти: Бубе -> Черви -> Пики -> Крести, и
  // убыванию ранга)
  CardDeck& DefaultSort();

  // Переопределение экземпляра класса (Перегруженный оператор присваивания)
  CardDeck& operator=(const CardDeck&);

  /* --------------------------------------------------------- */
  /*				      Геттеры - get'теры
   */
  /* --------------------------------------------------------- */

  // Вернуть максимальный размер деки
  int GetMaxSize() const { return SZ; };

  // Вернуть текущее кол-во карт в деке
  int GetCurrentSize() const;

  // Вернуть масть карты по её номеру в деке (Перегруженный оператор "()")
  int GetCurrentSuit(int) const;

  // Вернуть масть карты по её номеру в деке
  int operator()(int) const;

  // Вернуть ранг карты по её номеру в деке (Перегруженный оператор "[]")
  int GetCurrentRang(int) const;

  // Вернуть ранг карты по её номеру в деке
  int operator[](int) const;

  /* Получить подгруппу карт заданной масти из текущей деки (Возвращается новый
  экземпляр класса) Принимает в себя инт от 1 до 4:  '1' - Бубе, '2' - Черви,
  '3' - Пики, '4' - Крести */
  CardDeck& GetSuitDeck(int) const;

  /* --------------------------------------------------------- */
  /*						 Друзья класса
   */
  /* --------------------------------------------------------- */

  // Вввод состояния деки из входного потока (с возможным выбрасыванием
  // исключения)
  friend std::istream& operator>>(std::istream&, CardDeck&);

  // Вывод текущей деки в выходной поток
  friend std::ostream& operator<<(std::ostream&, const CardDeck&);

  // Деструктор (не по умолчанию, т.к. перед очисткой стека нужно удалить
  // массив)
  ~CardDeck();
};
}  // namespace CardDeckClass

#endif  // CARDDECKLIB_C_H
