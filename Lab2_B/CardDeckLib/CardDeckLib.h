#ifndef _CARDDECKLIB_H_
#define _CARDDECKLIB_H_

#include <iostream>

#define MAX_INT std::numeric_limits<std::streamsize>::max()

namespace CardDeckClass {


	// Шаблон функции проверки ввода числа ввода числа (1 в случае неудачи, и 0 при успехе)
	template <class T>
	int getNum(T& a, std::istream& stream) {
		int rc = 0;
		stream >> a;
		if (!stream.good())
			rc = 1;				// Обнаружена ошибка ввода
		stream.clear();
		stream.ignore(MAX_INT, '\n');
		return rc;
	};


	// Шаблон функции для ввода числа из входного потока
	template<class T>
	void input_Type(T& p) {
		while (getNum(p, std::cin))
			std::cout << "Пожалуйста, введите корректное число: --> ";
	}



	/* Структура одной карты
	 Вместо интов юзаются чары, чтобы сэкономить память массива, однако сортировка так же идет по номерам в  ASCII таблице */
	struct Card {
		// Ранг карты: от '0' до '9', ':' - Валет, ';' - Дама, '<' - Король, '=' - Туз, '>' - карты не существует
		char rang;	

		// Масть карты: '1' - Бубе, '2' - Черви, '3' - Пики, '4' - Крести, '0' - карты не существует
		char suit;		
	};

	class CardDeck {
	private:
		static const int SZ = 52;
		Card cards[SZ];
	public:
		/* --------------------------------------------------------- */
		/*				    	  Конструкторы					 	 */
		/* --------------------------------------------------------- */			

		// Пустой конструктор для инициализации экземпляров и массивов экземпляров класса по умолчанию
		CardDeck();		

		// Создание экземпляра класса с инициализацией количества карт, значения которых определяются с помощью генератора случайных чисел
		CardDeck(int);	

		// Создание экземпляра класса с инициализацией начального состояия одной карты
		CardDeck(int, int);							

		/* --------------------------------------------------------- */
		/*				      Сеттеры - set'теры					 */
		/* --------------------------------------------------------- */

		// Добавление новой карты к колоде (Перегруженный префиксный оператор "++")
		CardDeck& AddNewCard();		

		// Перегруженный оператор с таким функционалом
		CardDeck& operator ++ ();

		// Сортировка карт в деке по масти (Бубе -> Черви -> Пики -> Крести)
		CardDeck& SortSuit();		

		// Сортировка по условию лабы (по масти: Бубе -> Черви -> Пики -> Крести, и убыванию ранга)
		CardDeck& DefaultSort();				


		/* --------------------------------------------------------- */
		/*				      Геттеры - get'теры 					 */
		/* --------------------------------------------------------- */


		// Вернуть максимальный размер деки
		int GetMaxSize() const { return SZ; };	

		// Вернуть текущее кол-во карт в деке
		int GetCurrentSize() const;			

		// Найти индекс конкретной карты в колоде (Необходима только для 3А и 3Б, т.к. в фулл деке кол-во все карты индивидуальны)
		int FindCurrentCard(int, int) const;			

		// Вернуть масть карты по её номеру в деке (Перегруженный оператор "()")
		int GetCurrentSuit(int) const;

		// Перегруженный оператор с таким функционалом
		int operator () (int) const;

		// Вернуть ранг карты по её номеру в деке (Перегруженный оператор "[]")
		int GetCurrentRang(int) const;

		// Перегруженный оператор с таким функционалом
		int operator [] (int) const;			

		/* Получить подгруппу карт заданной масти из текущей деки (Возвращается новый экземпляр класса)
		Принимает в себя инт от 1 до 4:  '1' - Бубе, '2' - Черви, '3' - Пики, '4' - Крести */
		CardDeck& GetSuitDeck(int) const;							


		/* --------------------------------------------------------- */
		/*						 Друзья класса 						 */
		/* --------------------------------------------------------- */

		// Вввод состояния деки из входного потока (с возможным выбрасыванием исключения)
		friend std::istream& operator >> (std::istream&, CardDeck&);

		// Вывод текущей деки в выходной поток
		friend std::ostream& operator << (std::ostream&, const CardDeck&);

		// Деструктор (не по умолчанию, т.к. перед очисткой стека нужно удалить массив)
		//~CardDeck();
	};
}


#endif // !_CARDDECK_H_

